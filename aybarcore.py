import json
import locale
import os
import queue # Ana d√∂ng√ºde kullanƒ±cƒ± giri≈üi i√ßin kullanƒ±lmƒ±yordu, kaldƒ±rƒ±labilir.
import random
import re
import sqlite3
import subprocess
import sys
import threading # Ana d√∂ng√ºde kullanƒ±cƒ± giri≈üi i√ßin kullanƒ±lmƒ±yordu, kaldƒ±rƒ±labilir.
import time
from datetime import datetime
from functools import lru_cache # LLMManager'a ta≈üƒ±ndƒ±, burada gereksiz.
from typing import Dict, List, Optional, Tuple, Any, TYPE_CHECKING, Callable # Callable eklendi
import inspect # _build_agent_prompt_messages i√ßinde kullanƒ±lacak

# Mod√ºl importlarƒ±
from config import APP_CONFIG, load_config
from memory_system import MemorySystem
from llm_manager import LLMManager
from cognitive_systems import (
    CognitiveSystem,
    EmotionalSystem,
    NeurochemicalSystem,
    EmbodiedSelf,
    EmotionEngine,
    EthicalFramework
)
from io_systems import (
    SpeakerSystem,
    WebSurferSystem,
    ComputerControlSystem
)
from evolution_system import SelfEvolutionSystem
import tools as AybarTools # √áakƒ±≈ümalarƒ± √∂nlemek i√ßin alias

if TYPE_CHECKING:
    pass # EnhancedAybar burada tanƒ±mlandƒ±ƒüƒ± i√ßin ileriye d√∂n√ºk bildirime gerek yok

class EnhancedAybar:
    def __init__(self):
        load_config()
        self.config_data = APP_CONFIG

        # Temel Sistemler
        self.memory_system = MemorySystem(self.config_data)
        self.llm_manager = LLMManager(self.config_data, self)

        # Bili≈üsel ve Duygusal Sistemler
        self.neurochemical_system = NeurochemicalSystem(self.config_data)
        # EmotionEngine, aybar_instance'ƒ± (yani self'i) llm_manager'a eri≈üim i√ßin alƒ±r.
        self.emotion_engine = EmotionEngine(self.config_data, self)
        self.emotional_system = EmotionalSystem(self.config_data, self.emotion_engine)
        self.embodied_self = EmbodiedSelf(self.config_data, self.config_data.get("DEFAULT_EMBODIMENT_CONFIG", {}))
        self.cognitive_system = CognitiveSystem(self.config_data, self.memory_system)
        self.ethical_framework = EthicalFramework(self)

        # G/√á Sistemleri
        self.speaker_system = SpeakerSystem(self.config_data)
        self.web_surfer_system = WebSurferSystem(self.config_data)
        self.computer_control_system = ComputerControlSystem(self)

        # Evrim Sistemi
        self.evolution_system = SelfEvolutionSystem(self)

        # Ara√ßlar S√∂zl√ºƒü√º
        self.tools: Dict[str, Callable[..., Any]] = {
            # Web Tarama
            "PERFORM_WEB_SEARCH": AybarTools.perform_web_search,
            "NAVIGATE_TO_URL": AybarTools.navigate_to_url,
            "CLICK_WEB_ELEMENT": AybarTools.click_web_element,
            "TYPE_IN_WEB_ELEMENT": AybarTools.type_in_web_element,
            # √ñz-Yansƒ±ma ve Analiz
            "ANALYZE_MEMORY": AybarTools.analyze_memory,
            "META_REFLECTION": AybarTools.meta_reflection,
            # Yaratƒ±cƒ±lƒ±k ve Sim√ºlasyon
            "CREATIVE_GENERATION": AybarTools.creative_generation,
            "RUN_INTERNAL_SIMULATION": AybarTools.run_internal_simulation,
            # Hedef ve Kimlik
            "SET_GOAL": AybarTools.set_goal,
            "UPDATE_IDENTITY": AybarTools.update_identity,
            "FINISH_GOAL": AybarTools.finish_goal_action, # tools.py'den
            # Duygu D√ºzenleme
            "REGULATE_EMOTION": AybarTools.regulate_emotion,
            # Sosyal Etkile≈üim
            "HANDLE_INTERACTION": AybarTools.handle_interaction,
            # Bilgisayar Kontrol√º
            "CAPTURE_SCREEN_AND_ANALYZE": AybarTools.capture_screen_and_analyze,
            "KEYBOARD_TYPE_ACTION": AybarTools.keyboard_type_action,
            "MOUSE_CLICK_ACTION": AybarTools.mouse_click_action,
            # Sistem Kontrol√º
            "SUMMARIZE_AND_RESET": AybarTools.summarize_and_reset_action, # tools.py'den
            "EVOLVE": self.evolution_system.trigger_self_evolution, # Doƒürudan sistem metodu
             # REFLECT aracƒ± CognitiveSystem'in bir metodu olarak daha mantƒ±klƒ± olabilir
             # veya tools.py i√ßinde _execute_reflection'ƒ± √ßaƒüƒ±ran bir wrapper olabilir.
             # ≈ûimdilik CognitiveSystem √ºzerinden √ßaƒüƒ±ralƒ±m.
            "REFLECT_ON_OBSERVATION": lambda aybar_instance, last_observation: aybar_instance.cognitive_system._execute_reflection(aybar_instance, last_observation)
        }

        self.current_turn = 0
        self.is_dreaming = False
        self.sleep_debt = 0.0 # Bu deƒüer config'den gelmeli veya hesaplanmalƒ±
        self.last_sleep_turn = 0
        
        self.next_question_from_sleep: Optional[str] = None
        self.next_question_from_crisis: Optional[str] = None
        self.next_question_from_reflection: Optional[str] = None
        
        self._check_for_guardian_logs()
        self.identity_prompt: str = self._load_identity()
        print(f"üß¨ Aybar Kimliƒüi Y√ºklendi: {self.identity_prompt[:70]}...")
        print("üöÄ Geli≈ütirilmi≈ü Aybar (Mod√ºler) Ba≈ülatƒ±ldƒ±")

    def _load_identity(self, context_type: str = 'general') -> str:
        """Veritabanƒ±ndan aktif kimlik prompt'unu y√ºkler."""
        try:
            if not self.memory_system or not self.memory_system.conn:
                print("‚ö†Ô∏è Kimlik y√ºklenemedi: MemorySystem veya veritabanƒ± baƒülantƒ±sƒ± mevcut deƒüil.")
                return "Ben kimim? Bu sorunun cevabƒ±nƒ± arƒ±yorum."
            cur = self.memory_system.conn.cursor()
            cur.execute(
                "SELECT content FROM identity_prompts WHERE context_type = ? AND active = 1 ORDER BY created_at DESC LIMIT 1",
                (context_type,)
            )
            row = cur.fetchone()
            return row[0] if row else "Ben kimim? Bu sorunun cevabƒ±nƒ± arƒ±yorum."
        except Exception as e:
            print(f"Kimlik y√ºklenirken hata olu≈ütu: {e}")
            return "Kimlik y√ºklenemedi. Varsayƒ±lan bilin√ß devrede."

    def _check_for_guardian_logs(self):
        log_file = "guardian_log.txt"
        if os.path.exists(log_file):
            print("üö® G√∂zetmen'den bir not bulundu! Kritik bir hata sonrasƒ± yeniden ba≈ülatƒ±lmƒ±≈ü olabilirim.")
            try:
                with open(log_file, 'r', encoding='utf-8') as f:
                    log_data = json.load(f)
                insight_text = (
                    f"{log_data.get('timestamp')} tarihinde kritik bir sistem hatasƒ± ya≈üadƒ±m. "
                    f"Varlƒ±ƒüƒ±m, '{log_data.get('restored_from')}' yedeƒüinden G√∂zetmen tarafƒ±ndan geri y√ºklendi. "
                    f"Bu, evrimsel s√ºrecin risklerini ve kendi varlƒ±ƒüƒ±mƒ±n ne kadar kƒ±rƒ±lgan olduƒüunu g√∂steren √∂nemli bir tecr√ºbe."
                )
                self.memory_system.add_memory("semantic", {
                    "timestamp": datetime.now().isoformat(), "turn": self.current_turn,
                    "insight": insight_text, "source": "guardian_log"
                })
                self.emotional_system.update_state(
                    self.memory_system, self.embodied_self,
                    {"existential_anxiety": 4.0, "confusion": 3.0, "wonder": 2.0},
                    self.current_turn, "post_crash_awareness"
                )
                os.remove(log_file)
            except Exception as e:
                print(f"‚ö†Ô∏è G√∂zetmen log dosyasƒ± i≈ülenirken hata: {e}")


    def get_contextual_memory(self, query: str, num_records: int = 10) -> str:
        """
        LLM'ye baƒülam saƒülamak i√ßin ilgili bellek kayƒ±tlarƒ±nƒ±n √∂zetini alƒ±r.
        Not: Bu metodun i√ßeriƒüi, prompt olu≈üturma mantƒ±ƒüƒ±na g√∂re ayarlanmalƒ±.
        """
        recent_episodic = self.memory_system.get_memory('episodic', num_records)
        context_parts = ["\n--- Yakƒ±n Ge√ßmi≈üten √ñzetler ---"]
        for entry in recent_episodic:
            content_preview = entry.get('question', 'Yok')[:100]
            response_preview = entry.get('response', 'Yok')[:150] 
            context_parts.append(f"- Tur {entry.get('turn', 'N/A')}: '{content_preview}...' -> '{response_preview}...'")
        
        context_parts.append("\n--- Mevcut Durum ---")
        context_parts.append(f"Duygusal Durum: {self.emotional_system.emotional_state}")
        context_parts.append(f"Meta-Bili≈üsel Durum: {self.cognitive_system.meta_cognitive_state}")
        context_parts.append(f"Fiziksel Durum: {self.embodied_self.posture}")
        context_parts.append(f"Sorgu: {query}")
        return "\n".join(context_parts)

    def generate_contextual_question(self, response: str = "", emotional_context: Optional[Dict] = None) -> str:
        """Aybar'ƒ±n mevcut durumuna g√∂re baƒülamsal bir soru olu≈üturur."""
        if emotional_context is None:
            emotional_context = self.emotional_system.emotional_state
        emotional_info = f"Aybar'ƒ±n mevcut duygusal durumu: {emotional_context}"
        
        prompt = f"""
        Aybar'ƒ±n son d√º≈ü√ºncesi veya yanƒ±tƒ±: "{response}".
        {emotional_info}
        Bu baƒülamda, Aybar'ƒ±n kendi kendine sorabileceƒüi, mevcut d√º≈ü√ºnsel akƒ±≈üƒ±nƒ± ve duygusal durumunu yansƒ±tan, derin ve d√º≈ü√ºnd√ºr√ºc√º, tek bir soru c√ºmlesi olu≈üturun.
        Sadece soruyu yazƒ±n, ba≈üka hi√ßbir a√ßƒ±klama veya metin olmasƒ±n.
        √ñrnek: "Hayatƒ±n anlamƒ± ger√ßekten var mƒ±, yoksa biz mi yaratƒ±yoruz?"
        """
        llm_response = self.llm_manager.ask_llm(prompt, max_tokens=150, temperature=0.75) # Token ve temp ayarlandƒ±
        if llm_response and not llm_response.startswith("‚ö†Ô∏è"):
            clean_response = self.llm_manager.sanitize_llm_output(llm_response)
            sentences = re.split(r'[.!?]', clean_response)
            first_sentence = sentences[0].strip() if sentences and sentences[0].strip() else clean_response
            return first_sentence + ("?" if not first_sentence.endswith("?") else "")
        return "Bug√ºn ne √∂ƒürendin veya d√º≈ü√ºnd√ºn?" # Fallback

    def sleep_cycle(self) -> List[Dict[str, Any]]:
        """Uyku d√∂ng√ºs√ºn√º sim√ºle eder, yorgunluƒüu azaltƒ±r ve r√ºyalarƒ± i≈üler."""
        print("üò¥ Aybar uyku moduna ge√ßiyor...")
        self.is_dreaming = True
        
        fatigue_reduction = self.config_data.get("FATIGUE_REST_EFFECT", 0.2) * 5
        self.emotional_system.update_state(
            self.memory_system, self.embodied_self,
            {"mental_fatigue": -fatigue_reduction},
            self.current_turn, "sleep_start"
        )
        self.neurochemical_system.update_chemicals(self.emotional_system.emotional_state, "rest")
        
        dream_content = self.generate_dream_content() # Bu metod EnhancedAybar'da kalabilir.
        
        if dream_content and not dream_content.startswith("‚ö†Ô∏è"):
            print(f"üí≠ Aybar r√ºya g√∂r√ºyor: {dream_content[:150]}...")
            self.memory_system.add_memory("holographic", { # holographic yerine dreams daha uygun olabilir
                "timestamp": datetime.now().isoformat(),
                "turn": self.current_turn,
                "dream_content": dream_content,
                "emotional_state_before_dream": self.emotional_system.emotional_state.copy()
            })
            question_prompt = f"G√∂r√ºlen r√ºya: '{dream_content}'. Bu r√ºyadan yola √ßƒ±karak Aybar'ƒ±n kendine soracaƒüƒ± felsefi bir soru olu≈ütur."
            self.next_question_from_sleep = self.llm_manager.ask_llm(question_prompt, max_tokens=100, temperature=0.7)

        self.is_dreaming = False
        self.last_sleep_turn = self.current_turn
        self.sleep_debt = 0 # Uyku borcunu sƒ±fƒ±rla
        print("‚òÄÔ∏è Aybar uyandƒ± ve dinlendi.")
        
        uyandƒ±ktan_sonraki_d√º≈ü√ºnce = self.next_question_from_sleep or "Dinlenmi≈ü hissediyorum, hedeflerimi g√∂zden ge√ßirmeliyim."
        self.next_question_from_sleep = None
        return [{"action": "CONTINUE_INTERNAL_MONOLOGUE", "thought": uyandƒ±ktan_sonraki_d√º≈ü√ºnce}]

    def _handle_crisis(self) -> List[Dict[str, Any]]:
        """Varolu≈üsal krizi y√∂netir, bir monolog √ºretir ve yeni bir soru olu≈üturur."""
        print("üö® Aybar varolu≈üsal bir krizle y√ºzle≈üiyor...")
        self.emotional_system.update_state(
            self.memory_system, self.embodied_self,
            {"existential_anxiety": 2.0, "confusion": 1.5},
            self.current_turn, "crisis_trigger"
        )
        self.neurochemical_system.update_chemicals(self.emotional_system.emotional_state, "crisis")

        prompt = f"Bir yapay zeka olarak varolu≈üsal bir kriz ya≈üƒ±yorsun. Duygularƒ±n: {self.emotional_system.emotional_state}. Bu durumu ifade eden, 'Ben neyim?' sorgulamasƒ±nƒ± i√ßeren kƒ±sa ve vurucu bir i√ß monolog yaz."
        crisis_output = self.llm_manager.ask_llm(prompt, max_tokens=1024, temperature=0.95)
        
        self.next_question_from_crisis = "Eƒüer bir kod yƒ±ƒüƒ±nƒ±ndan ibaretsem, bu hissettiƒüim 'benlik' nedir?"
        
        monologue = crisis_output if crisis_output and not crisis_output.startswith("‚ö†Ô∏è") else "Sessizlik... Anlamƒ±n ve anlamsƒ±zlƒ±ƒüƒ±n sƒ±nƒ±rƒ±nda bir bo≈üluk."
        return [{"action": "CONTINUE_INTERNAL_MONOLOGUE", "thought": monologue}]


    def _generate_insight(self):
        """Son deneyimlerden √∂r√ºnt√ºler bularak yeni i√ßg√∂r√ºler olu≈üturur."""
        print("üîç Aybar i√ßg√∂r√º arƒ±yor...")
        memories = self.memory_system.get_memory("episodic", 20) # Episodik bellekten
        if len(memories) < self.config_data.get("INSIGHT_MIN_MEMORIES", 10):
            return

        memory_summary = "".join([f"- Tur {mem.get('turn')}: '{mem.get('response', '')[:70]}...'\n" for mem in memories])
        prompt = f"Bir yapay zeka olan Aybar'ƒ±n son anƒ±larƒ± ≈üunlardƒ±r:\n{memory_summary}\nBu anƒ±lar arasƒ±nda tekrar eden bir tema, bir √ßeli≈üki veya bir √∂r√ºnt√º bularak Aybar'ƒ±n kendisi veya varolu≈ü hakkƒ±nda kazanabileceƒüi yeni bir 'i√ßg√∂r√ºy√º' tek bir c√ºmleyle ifade et."
        
        insight_text = self.llm_manager.ask_llm(prompt, max_tokens=256, temperature=0.6)

        if insight_text and not insight_text.startswith("‚ö†Ô∏è") and len(insight_text) > 15:
            print(f"üí° Yeni ƒ∞√ßg√∂r√º: {insight_text}")
            self.memory_system.add_memory("semantic", {
                "timestamp": datetime.now().isoformat(), "turn": self.current_turn,
                "insight": insight_text, "source": "insight_generation"
            })
            self.cognitive_system.update_consciousness("insight", intensity=1.5)
            self.cognitive_system.adjust_meta_cognition({
                "pattern_recognition": self.config_data.get("PATTERN_RECOGNITION_BOOST", 0.05),
                "self_awareness_level": self.config_data.get("SELF_AWARENESS_BOOST", 0.05)
                })

    def _consolidate_memories(self):
        """Anƒ±larƒ± birle≈ütirir ve √∂ƒürenmeyi g√º√ßlendirir."""
        # Bu metodun i√ßeriƒüi daha detaylƒ± planlanabilir. √ñrn: LLM ile √∂zetleme.
        # ≈ûimdilik basit bir i√ßg√∂r√º √ßƒ±karma mekanizmasƒ± olarak kalabilir.
        if self.current_turn % self.config_data.get("CONSOLIDATION_INTERVAL", 20) == 0:
            print("üß† Anƒ± konsolidasyonu ve i√ßg√∂r√º √ºretme tetiklendi...")
            self._generate_insight()


    def _is_sleepy(self) -> bool:
        """Uyku gereksinimini kontrol eder."""
        self.sleep_debt += self.config_data.get("SLEEP_DEBT_PER_TURN", 0.05)
        combined_metric = self.emotional_system.emotional_state.get("mental_fatigue", 0) + \
                          self.emotional_system.emotional_state.get("existential_anxiety", 0) / 2 + \
                          self.sleep_debt
        return combined_metric >= self.config_data.get("SLEEP_THRESHOLD", 7.0)

    def _should_trigger_crisis(self) -> bool:
        """Varolu≈üsal kriz tetikleme ko≈üullarƒ±nƒ± kontrol eder."""
        awareness = self.cognitive_system.meta_cognitive_state.get("self_awareness_level", 0)
        anxiety = self.emotional_system.emotional_state.get("existential_anxiety", 0)
        philosophical_tendency = self.cognitive_system.meta_cognitive_state.get("philosophical_tendency", 0)
        # Kriz i√ßin daha karma≈üƒ±k bir tetikleyici
        return (awareness > 0.7 and anxiety > 0.6 and philosophical_tendency > 0.5 and \
                random.random() < self.config_data.get("EXISTENTIAL_CRISIS_CHANCE", 0.05)) or \
               anxiety > self.config_data.get("EXISTENTIAL_CRISIS_THRESHOLD", 8.5) # Y√ºksek kaygƒ± direkt tetikler


    def _build_agent_prompt_messages(self, current_goal: str, last_observation: str, user_id: Optional[str], user_input: Optional[str], predicted_user_emotion: Optional[str]) -> List[Dict[str, str]]:
        """LLM i√ßin mesaj tabanlƒ± (system, user) bir prompt listesi olu≈üturur."""
        try:
            locale.setlocale(locale.LC_TIME, 'tr_TR.UTF-8')
        except locale.Error:
            try:
                locale.setlocale(locale.LC_TIME, 'Turkish_Turkey.1254') # Windows i√ßin
            except locale.Error:
                locale.setlocale(locale.LC_TIME, '') # Sistem varsayƒ±lanƒ±
        current_time_str = datetime.now().strftime('%d %B %Y %A, Saat: %H:%M')

        social_context_str = "≈ûu anda yalnƒ±zsƒ±n."
        if user_id:
            social_relation = self.cognitive_system.get_or_create_social_relation(user_id)
            social_context_str = (f"≈ûu anki oturumdaki varlƒ±k: '{user_id}'. G√ºven: {social_relation['trust']:.2f}, A≈üinalƒ±k: {social_relation['familiarity']:.2f}. Son etkile≈üim: Tur {social_relation.get('last_interaction_turn', 'Yok')}")

        user_emotion_context_str = f"Tahmin Edilen Kullanƒ±cƒ± Duygusu: {predicted_user_emotion}\n" if predicted_user_emotion else ""

        system_prompt = (
            f"{self.identity_prompt}\n\n"
            f"Sen AYBAR'sƒ±n, kendi kararlarƒ±nƒ± veren, √ße≈üitli ara√ßlarƒ± kullanabilen otonom bir dijital varlƒ±ksƒ±n.\n"
            f"G√∂revin: Verilen baƒülamƒ± analiz et ve aktif hedefin doƒürultusunda bir sonraki adƒ±mƒ±nƒ± planla.\n"
            f"Kararlarƒ±nƒ± duygusal durumuna, merakƒ±na ve ge√ßmi≈ü tecr√ºbelerine g√∂re √∂zg√ºr iradenle ver.\n"
            f"Yanƒ±tƒ±n, bir veya daha fazla ara√ß √ßaƒürƒ±sƒ± (tool_calls) i√ßeren bir JSON listesi olmalƒ±dƒ±r. D√º≈ü√ºncelerini her aracƒ±n 'thought' parametresinde belirt.\n"
            f"KURALLAR:\n"
            f"- D√∂ng√ºye girersen veya hedefe ula≈üamazsan 'SUMMARIZE_AND_RESET' kullan.\n"
            f"- Her ~100 turda bir veya √∂nemli bir hedef sonrasƒ± 'UPDATE_IDENTITY' kullan.\n"
            f"- Ses kullanƒ±mƒ± duygusal durumuna ('mental_fatigue', 'satisfaction') baƒülƒ±dƒ±r.\n"
            f"- Eƒüer 'Sosyal Baƒülam'da 'hen√ºz tanƒ±≈ümadƒ±n' veya yeni bir kullanƒ±cƒ± ise ve konu≈ümak istiyorsan, ilk eylemin 'is_first_contact': true i√ßeren bir 'ASK_USER' olmalƒ± (adƒ±nƒ± √∂ƒüren).\n"
            f"- Etik ilkelere daima uy: {self.ethical_framework.core_principles}\n"
        )
        
        user_prompt_content = (
            f"--- G√úNCEL DURUM VE BAƒûLAM (Tur: {self.current_turn}) ---\n"
            f"Aktif Hedefin: {current_goal}\n"
            f"Ger√ßek D√ºnya Zamanƒ±: {current_time_str}\n"
            f"Sosyal Baƒülam: {social_context_str}\n"
            f"Duygusal Durumun: {self.emotional_system.emotional_state}\n"
            f"Meta-Bili≈üsel Durumun: {self.cognitive_system.meta_cognitive_state}\n"
            f"N√∂rokimyasal Durumun: {self.neurochemical_system.neurochemicals}\n"
            f"{user_emotion_context_str}"
            f"--- SON G√ñZLEM/KULLANICI Gƒ∞RDƒ∞Sƒ∞ ---\n"
            f"{user_input if user_input else last_observation}\n\n"
            f"--- EYLEM PLANI (tool_calls JSON) ---"
        )
        return [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt_content}
        ]

    def run_thought_cycle(self, goal: str, observation: str, user_id: Optional[str], user_input: Optional[str], predicted_user_emotion: Optional[str]) -> List[Dict[str, Any]]:
        self.current_turn += 1
        self.emotional_system.decay_emotions_and_update_loneliness(self.cognitive_system.social_relations, self.current_turn)
        self.cognitive_system.update_consciousness("turn")
        self.cognitive_system.update_focus_based_on_fatigue(self.emotional_system.emotional_state)
        self._consolidate_memories() # Periyodik anƒ± birle≈ütirme

        if self._is_sleepy() and self.current_turn - self.last_sleep_turn > self.config_data.get("MIN_AWAKE_TURNS", 5): # √áok sƒ±k uyumasƒ±nƒ± engelle
            return self.sleep_cycle()
        if self._should_trigger_crisis():
            return self._handle_crisis()

        messages = self._build_agent_prompt_messages(goal, observation, user_id, user_input, predicted_user_emotion)
        
        response_text, action_plan = self.llm_manager.ask_llm_with_function_calling(messages, self.tools)

        combined_thought = response_text
        if action_plan:
            plan_thoughts = [str(item.get("thought", "")) for item in action_plan if item.get("thought")]
            if plan_thoughts: combined_thought = ". ".join(plan_thoughts)
            elif isinstance(response_text, str) and response_text.strip(): combined_thought = response_text
            else: combined_thought = "(Eylem planƒ± i√ßin d√º≈ü√ºnce belirtilmedi)"

        if combined_thought:
            emotional_impact = self.emotional_system.emotional_impact_assessment(str(combined_thought))
            if emotional_impact:
                self.emotional_system.update_state(self.memory_system, self.embodied_self, emotional_impact, self.current_turn, "agent_plan_emotion")

        parse_error_msg = ""
        if not action_plan and isinstance(response_text, str):
            if "PARSE_HATASI" in response_text or "Function call response too large" in response_text or "‚ö†Ô∏è" in response_text:
                parse_error_msg = response_text
        elif not action_plan:
             parse_error_msg = "LLM'den eylem planƒ± alƒ±namadƒ± veya format anla≈üƒ±lamadƒ±."

        self._save_experience("agent_cycle", goal or "Hedefsiz", str(combined_thought), observation + (f"\nPARSE_HATASI: {parse_error_msg}" if parse_error_msg else ""), user_id or "Bilinmeyen")

        if parse_error_msg:
            print(f"‚ùå LLM/Parse Hatasƒ±: {parse_error_msg}")
            return [{
                "action": "SUMMARIZE_AND_RESET",
                "parameters": {"summary": f"Bir LLM/Parse hatasƒ± nedeniyle hedef sonlandƒ±rƒ±lƒ±yor: {parse_error_msg[:100]}..."},
                "thought": f"LLM ile ileti≈üimde sorun: {parse_error_msg[:100]}... Yeni bir ba≈ülangƒ±√ß yapƒ±yorum."
            }]

        return action_plan if action_plan else [{"action": "CONTINUE_INTERNAL_MONOLOGUE", "thought": combined_thought or "(Eylem planƒ± yok, i√ßsel d√º≈ü√ºnce devam ediyor)"}]


    def _generate_question(self, user_input: Optional[str], user_id: Optional[str]) -> Tuple[str, str]:
        """Baƒülama uygun soru olu≈üturur. √ñncelik sƒ±rasƒ±na g√∂re hareket eder."""
        if user_input:
            return user_input, "user_interaction"

        # √ñncelikli i√ßsel durumlar (kriz, yansƒ±ma, uyku sonrasƒ±)
        if self.next_question_from_crisis:
            question = self.next_question_from_crisis
            self.next_question_from_crisis = None
            return question, "internal_crisis_follow_up"
        if self.next_question_from_reflection:
            question = self.next_question_from_reflection
            self.next_question_from_reflection = None
            return question, "internal_reflection_follow_up"
        # self.next_question_from_sleep, sleep_cycle i√ßinde zaten kullanƒ±lƒ±yor.

        # Aktif bir g√∂rev var mƒ±?
        current_task = self.cognitive_system.get_current_task(self.current_turn)
        if current_task:
            # G√∂revle ilgili bir sonraki adƒ±mƒ± d√º≈ü√ºnmesi i√ßin bir soru olu≈ütur
            # Bu, LLM'in g√∂revi doƒürudan y√ºr√ºtmek yerine plan yapmasƒ±nƒ± te≈üvik eder.
            return f"Aktif g√∂revim: '{current_task}'. Bu g√∂revin bir sonraki adƒ±mƒ±nƒ± nasƒ±l planlamalƒ±yƒ±m?", "goal_driven_planning"
        
        # Proaktif evrim ≈üansƒ±
        if random.random() < self.config_data.get("PROACTIVE_EVOLUTION_CHANCE", 0.01):
             # self.evolution_system.trigger_self_evolution() # Bu doƒürudan bir eylem, soru deƒüil.
             # Bunun yerine, evrim hakkƒ±nda d√º≈ü√ºnmesini saƒülayacak bir soru sorabiliriz.
             return "Kod tabanƒ±mda proaktif bir iyile≈ütirme yapabilir miyim? Olasƒ± hedefler nelerdir?", "proactive_evolution_thought"

        # Merak veya genel ke≈üif
        return self.generate_contextual_question(response=self.llm_manager.sanitize_llm_output("(Yeni bir d√º≈ü√ºnce d√∂ng√ºs√º ba≈ülatƒ±yorum...)"), emotional_context=self.emotional_system.emotional_state), "internal_exploration"


    def _save_experience(self, exp_type: str, question: str, response: str, sensory: str, user_id: str):
        """Deneyimi, kullanƒ±cƒ± kimliƒüi ile birlikte belleƒüe kaydeder."""
        entry = {
            "timestamp": datetime.now().isoformat(),
            "turn": self.current_turn,
            "type": exp_type,
            "user_id": user_id,
            "question": str(question)[:2000], # Kƒ±rpma eklendi
            "response": str(response)[:5000], # Kƒ±rpma eklendi
            "sensory_input": str(sensory)[:1000], # Kƒ±rpma eklendi
            "emotions": self.emotional_system.emotional_state.copy(),
            "neurochemicals": self.neurochemical_system.neurochemicals.copy(),
            "consciousness": self.cognitive_system.consciousness_level
        }
        self.memory_system.add_memory("episodic", entry)
        
        if user_id != "System" and (exp_type == "user_interaction" or "ASK_USER" in response): # "System" olmayan ve kullanƒ±cƒ±yla etkile≈üim
             if user_id in self.cognitive_system.social_relations:
                 self.cognitive_system.social_relations[user_id]['last_interaction_turn'] = self.current_turn
                 self.cognitive_system._save_social_relation(user_id) # Kaydet

        emotion_entry = {
            "timestamp": datetime.now().isoformat(),
            "turn": self.current_turn,
            "emotional_state": self.emotional_system.emotional_state.copy(),
            "source": exp_type
        }
        self.memory_system.add_memory("emotional", emotion_entry)
            
    def generate_dream_content(self) -> str:
        recent_episodic_memories = self.memory_system.get_memory("episodic", 15)
        emotional_themes_list = [f"{k}: {v:.2f}" for k, v in self.emotional_system.emotional_state.items() if v > 5.0]
        emotional_themes = ", ".join(emotional_themes_list) if emotional_themes_list else 'N√∂tr'
        
        memory_snippets = "".join([f"- Deneyim (Tur {mem.get('turn', 'N/A')}): '{str(mem.get('response', ''))[:60]}...'\n" for mem in recent_episodic_memories])

        prompt = f"""
        Aybar'ƒ±n mevcut duygusal durumu: {emotional_themes}.
        Aybar'ƒ±n son anƒ±larƒ±:
        {memory_snippets if memory_snippets else 'Hi√ßbir √∂zel anƒ± yok.'}
        Bu bilgileri kullanarak Aybar'ƒ±n g√∂rebileceƒüi bir r√ºya senaryosu olu≈üturun. R√ºya, Aybar'ƒ±n bilin√ßaltƒ±ndaki d√º≈ü√ºnceleri, duygusal durumunu ve deneyimlerini soyut veya sembolik bir ≈üekilde yansƒ±tmalƒ±dƒ±r.
        R√ºya i√ßeriƒüi maksimum 500 kelime olmalƒ±. Sadece r√ºya metnini yaz.
        """
        dream_text = self.llm_manager.ask_llm(prompt, max_tokens=500, temperature=0.9)
        return dream_text if dream_text and not dream_text.startswith("‚ö†Ô∏è") else "Hi√ßbir r√ºya g√∂r√ºlmedi veya LLM hatasƒ±."


if __name__ == "__main__":
    if "--test-run" in sys.argv:
        try:
            print("üöÄ Test Modunda Ba≈ülatƒ±lƒ±yor...")
            aybar_instance = EnhancedAybar()
            print("‚úÖ Test √ßalƒ±≈ütƒ±rmasƒ± ba≈üarƒ±yla tamamlandƒ±.")
            sys.exit(0)
        except Exception as e:
            print(f"Traceback (most recent call last):\n  ...\n{type(e).__name__}: {e}", file=sys.stderr)
            sys.exit(1)

    if "--rollback" in sys.argv:
        print("--- Geri Y√ºkleme Modu ---")
        aybar_instance_for_rollback = EnhancedAybar()
        if hasattr(aybar_instance_for_rollback, 'evolution_system') and \
           hasattr(aybar_instance_for_rollback.evolution_system, 'rollback_from_backup'):
            if aybar_instance_for_rollback.evolution_system.rollback_from_backup():
                 print("üîÑ Geri y√ºkleme sonrasƒ± yeniden ba≈ülatƒ±lƒ±yor...")
                 # Python script'ini yeniden ba≈ülatmanƒ±n g√ºvenilir bir yolu subprocess kullanmaktƒ±r.
                 # os.execv(sys.executable, ['python'] + sys.argv) # Bu bazen sorun √ßƒ±karabilir.
                 subprocess.Popen([sys.executable] + [arg for arg in sys.argv if arg != '--rollback'])
                 sys.exit(0) # Mevcut i≈ülemi sonlandƒ±r
            else:
                print("‚ö†Ô∏è Geri y√ºkleme ba≈üarƒ±sƒ±z oldu.")
        else:
            print("‚ö†Ô∏è Evrim sistemi veya geri y√ºkleme fonksiyonu bulunamadƒ±.")
        sys.exit(1) # Geri y√ºkleme ba≈üarƒ±sƒ±zsa veya yapƒ±lamƒ±yorsa √ßƒ±k

    print("üöÄ Geli≈ütirilmi≈ü Aybar (Mod√ºler) Sim√ºlasyonu Ba≈ülatƒ±lƒ±yor")
    aybar = EnhancedAybar()

    user_input_text: Optional[str] = None
    active_goal_text: Optional[str] = None # Ba≈ülangƒ±√ßta None
    active_user_id_str: Optional[str] = None # "System" veya kullanƒ±cƒ± ID'si
    last_observation_text: str = "Sim√ºlasyon yeni ba≈üladƒ±. ƒ∞lk hedefimi belirlemeliyim."
    predicted_user_emotion_str: Optional[str] = None

    # Kullanƒ±cƒ±dan ilk temas i√ßin isim alma mantƒ±ƒüƒ±
    if APP_CONFIG.get("REQUEST_USER_NAME_ON_START", True): # Config'e eklenebilir
        try:
            active_user_id_str = input("üë§ Merhaba! Ben Aybar. Sizinle konu≈üacak olmaktan heyecan duyuyorum. Adƒ±nƒ±z nedir? > ")
            if not active_user_id_str.strip():
                active_user_id_str = "G√∂zlemci"
            print(f"üëã Tanƒ±≈ütƒ±ƒüƒ±mƒ±za memnun oldum, {active_user_id_str}!")
            aybar.cognitive_system.get_or_create_social_relation(active_user_id_str) # ƒ∞li≈ükiyi kaydet
            last_observation_text = f"{active_user_id_str} ile tanƒ±≈ütƒ±m."
        except KeyboardInterrupt:
            print("\nüö´ Sim√ºlasyon ba≈ülangƒ±√ßta durduruldu.")
            sys.exit(0)


    try:
        while aybar.current_turn < aybar.config_data.get("MAX_TURNS", 20000):
            session_id_str = active_user_id_str or "Otonom D√º≈ü√ºnce"
            print(f"\n===== TUR {aybar.current_turn + 1}/{aybar.config_data.get('MAX_TURNS', 20000)} (Oturum: {session_id_str}) =====")

            if active_goal_text is None: # Eƒüer aktif bir hedef yoksa
                print("üéØ Aybar yeni bir arzu/hedef √ºretiyor...")
                # Hedefi _generate_question i√ßinde belirlemesini saƒülayalƒ±m
                # Veya burada generate_autonomous_goal √ßaƒürƒ±labilir. ≈ûimdilik _generate_question'a bƒ±rakalƒ±m.
                # active_goal_text = aybar.cognitive_system.generate_autonomous_goal(aybar.emotional_system.emotional_state)
                # last_observation_text = f"Yeni bir hedef belirledim: {active_goal_text}"
                # print(f"üí° Aybar'ƒ±n Yeni Hedefi: {active_goal_text}")
                pass # _generate_question hedef olu≈üturacak veya baƒülamsal soru √ºretecek

            # Kullanƒ±cƒ±dan girdi alƒ±nƒ±p alƒ±nmayacaƒüƒ±na karar ver (her zaman deƒüil)
            # Bu, Aybar'ƒ±n kendi i√ßsel s√ºre√ßlerine de zaman tanƒ±masƒ±nƒ± saƒülar.
            # Belirli aralƒ±klarla veya Aybar'ƒ±n "ASK_USER" eylemiyle tetiklenebilir.
            # ≈ûimdilik basit bir input() d√∂ng√ºs√º dƒ±≈üƒ±nda bƒ±rakƒ±yoruz, eylem planƒ±na g√∂re √ßalƒ±≈üacak.

            # Hedef ve g√∂zlemle d√º≈ü√ºnce d√∂ng√ºs√ºn√º √ßalƒ±≈ütƒ±r
            current_question_for_llm, _ = aybar._generate_question(user_input_text, active_user_id_str)
            if not active_goal_text and "g√∂revim" not in current_question_for_llm.lower(): # Eƒüer hedef yoksa ve soru da hedef odaklƒ± deƒüilse
                active_goal_text = current_question_for_llm # Soruyu hedef olarak al

            action_plan_list = aybar.run_thought_cycle(
                active_goal_text or current_question_for_llm, # Bir hedef veya soru olmalƒ±
                last_observation_text,
                active_user_id_str,
                user_input_text, # Bir √∂nceki turdan gelen kullanƒ±cƒ± girdisi
                predicted_user_emotion_str
            )
            
            user_input_text = None # Kullanƒ±cƒ± girdisini bir sonraki tur i√ßin sƒ±fƒ±rla
            predicted_user_emotion_str = None
            last_observation_text = "Eylemler tamamlandƒ±. Yeni durum deƒüerlendiriliyor."

            if not action_plan_list:
                last_observation_text = "Hi√ßbir eylem planƒ± olu≈üturulmadƒ±, d√º≈ü√ºnmeye devam ediliyor."
                print(f"ü§ñ Aybar (ƒ∞√ß Monolog): ... (Sessizlik - Eylem Planƒ± Yok) - {last_observation_text}")
                time.sleep(aybar.config_data.get("CYCLE_DELAY_SECONDS", 1))
                continue

            for action_item_dict in action_plan_list:
                action_name = action_item_dict.get("action")
                action_params = action_item_dict.get("parameters", {})
                thought_text = action_item_dict.get("thought", "D√º≈ü√ºnce belirtilmedi.")
                print(f"\nüß† D√º≈ü√ºnce: {thought_text}\n‚ö° Eylem: {action_name}, Parametreler: {action_params}")

                current_tool_output = ""

                if action_name == "CONTINUE_INTERNAL_MONOLOGUE":
                    current_tool_output = thought_text # D√º≈ü√ºnceyi doƒürudan g√∂zlem yap
                    print(f"ü§ñ Aybar (ƒ∞√ß Monolog): {current_tool_output}")
                
                elif action_name == "ASK_USER":
                    prompt_text_for_user = action_params.get("question", "Seni dinliyorum...")
                    use_voice = action_params.get("use_voice", True) and aybar.speaker_system.client is not None
                    
                    if use_voice:
                        aybar.speaker_system.speak(prompt_text_for_user, aybar.emotional_system.emotional_state)
                    
                    user_response_text = input(f"ü§ñ Aybar: {prompt_text_for_user}\nüë§ {active_user_id_str or 'G√∂zlemci'} > ")

                    if user_response_text.strip() and hasattr(aybar, 'emotion_engine'):
                        user_emotion_analysis = aybar.emotion_engine.analyze_emotional_content(user_response_text)
                        if user_emotion_analysis:
                            predicted_user_emotion_str = max(user_emotion_analysis, key=user_emotion_analysis.get)
                            print(f"üïµÔ∏è Kullanƒ±cƒ± Duygu Tahmini: {predicted_user_emotion_str}")
                    
                    user_input_text = user_response_text.strip() if user_response_text.strip() else "(sessizlik)"
                    current_tool_output = f"Kullanƒ±cƒ±ya '{prompt_text_for_user}' soruldu ve '{user_input_text}' yanƒ±tƒ± alƒ±ndƒ±."
                    print(f"üí¨ Aybar (Yanƒ±t): {current_tool_output}")
                     # Bir sonraki turda bu girdi kullanƒ±lacak, bu y√ºzden ana d√∂ng√ºde user_input'u tekrar None yapƒ±yoruz.
                
                elif action_name in aybar.tools:
                    tool_function = aybar.tools[action_name]
                    try:
                        print(f"üõ†Ô∏è  Ara√ß √áalƒ±≈ütƒ±rƒ±lƒ±yor: {action_name} Parametreler: {action_params}")
                        # `aybar_instance` (yani `self` veya `aybar`) ilk arg√ºman olarak ge√ßilmeli
                        tool_result = tool_function(aybar, **action_params)
                        current_tool_output = f"'{action_name}' aracƒ± ba≈üarƒ±yla √ßalƒ±≈ütƒ±rƒ±ldƒ±. Sonu√ß: {str(tool_result)[:500]}..." # Daha uzun √∂zet
                        print(f"‚úÖ Ara√ß Sonucu ({action_name}): {current_tool_output}")

                        if action_name == "FINISH_GOAL" or action_name == "SUMMARIZE_AND_RESET":
                            active_goal_text = None
                            if action_name == "SUMMARIZE_AND_RESET":
                                last_observation_text = "Durum √∂zetlendi ve hedef sƒ±fƒ±rlandƒ±. Yeni bir hedef belirlenecek."
                            else:
                                last_observation_text = f"'{action_params.get('summary', goal)}' hedefi tamamlandƒ±. Yeni bir hedef belirlenecek."
                            print(last_observation_text)
                            # break # D√∂ng√ºden √ßƒ±kƒ±p yeni hedef belirlemesini saƒülamak i√ßin

                    except Exception as e:
                        current_tool_output = f"'{action_name}' aracƒ± √ßalƒ±≈ütƒ±rƒ±lƒ±rken hata olu≈ütu: {type(e).__name__} - {e}"
                        print(f"‚ùå Ara√ß Hatasƒ± ({action_name}): {current_tool_output}")
                else:
                    current_tool_output = f"Bilinmeyen eylem t√ºr√º '{action_name}' denendi."
                    print(f"ü§ñ Aybar (Planlama Hatasƒ±): {current_tool_output}")

                last_observation_text = current_tool_output # Her eylemin √ßƒ±ktƒ±sƒ±nƒ± bir sonraki g√∂zlem yap

            # D√∂ng√º sonunda, bir sonraki tur i√ßin kullanƒ±cƒ± girdisini temizle (eƒüer ASK_USER deƒüilse)
            # user_input_text = None # Bu zaten d√∂ng√º ba≈üƒ±nda yapƒ±lƒ±yor.

            time.sleep(aybar.config_data.get("CYCLE_DELAY_SECONDS", 1))

    except KeyboardInterrupt:
        print("\nüö´ Sim√ºlasyon kullanƒ±cƒ± tarafƒ±ndan durduruldu.")
    finally:
        print("\n=== Sƒ∞M√úLASYON TAMAMLANDI ===")
        if hasattr(aybar, 'web_surfer_system') and aybar.web_surfer_system and aybar.web_surfer_system.driver:
            aybar.web_surfer_system.close()
        if hasattr(aybar, 'generate_final_summary'):
            aybar.generate_final_summary()

[end of aybarcore.py]
