import numpy as np
import json
from datetime import datetime
from typing import Dict, List, Optional, Tuple

import re # re importu dosya ba≈üƒ±na ta≈üƒ±ndƒ±
import random # random importu dosya ba≈üƒ±na ta≈üƒ±ndƒ±
from typing import TYPE_CHECKING # TYPE_CHECKING importu eklendi

# EnhancedAybar ve MemorySystem i√ßin ileriye d√∂n√ºk bildirimler (type hinting i√ßin)
if TYPE_CHECKING: # if False yerine if TYPE_CHECKING kullanƒ±ldƒ±
    from aybarcore import EnhancedAybar
    from memory_system import MemorySystem
    # from config import Config # Bu artƒ±k kullanƒ±lmƒ±yor, Dict kullanƒ±lƒ±yor


class EmotionEngine:
    """
    LLM kullanarak metinlerin duygusal i√ßeriƒüini analiz eden uzman sistem.
    """
    def __init__(self, config_data: Dict, aybar_instance: "EnhancedAybar"):
        self.config_data = config_data
        self.aybar = aybar_instance
        self.emotion_list = [
            "curiosity", "confusion", "satisfaction",
            "existential_anxiety", "wonder", "mental_fatigue", "loneliness"
        ]

    def analyze_emotional_content(self, text: str) -> Dict[str, float]:
        """Verilen metnin duygusal imzasƒ±nƒ± √ßƒ±karƒ±r."""
        if not hasattr(self.aybar, 'llm_manager'):
            print("‚ö†Ô∏è EmotionEngine: LLMManager bulunamadƒ±.")
            return {}

        psychologist_prompt = f"""
        Sen, metinlerdeki duygusal tonu ve alt metni analiz eden uzman bir psikologsun.
        G√∂revin, sana verilen metni okumak ve a≈üaƒüƒ±daki listede bulunan duygularƒ±n varlƒ±ƒüƒ±nƒ± deƒüerlendirmektir.
        Duygu Listesi: {self.emotion_list}
        Analizini, sadece ve sadece bir JSON objesi olarak d√∂nd√ºr.
        JSON objesinin anahtarlarƒ± duygu isimleri, deƒüerleri ise o duygunun metindeki varlƒ±k g√ºc√ºn√º temsil eden -1.0 ile 1.0 arasƒ±nda bir float sayƒ± olmalƒ±dƒ±r.
        Sadece metinde belirgin olarak hissettiƒüin duygularƒ± JSON'a ekle.
        √ñrnek √áƒ±ktƒ±: {{"existential_anxiety": 0.7, "wonder": 0.4}}
        Analiz Edilecek Metin:
        ---
        {text[:2000]}
        ---
        JSON Analizi:
        """

        response_text = self.aybar.llm_manager.ask_llm(psychologist_prompt, temperature=0.3, max_tokens=256)

        try:
            # re importu dosya ba≈üƒ±na alƒ±ndƒ±
            json_match = re.search(r'\{.*?\}', response_text, re.DOTALL)
            if not json_match:
                return {}
            return json.loads(json_match.group(0))
        except json.JSONDecodeError:
            return {}


class EmotionalSystem:
    """Duygusal durum ve etkile≈üimleri y√∂netir."""
    def __init__(self, config_data: Dict, emotion_engine: "EmotionEngine"): # EmotionEngine i√ßin forward reference
        self.config_data = config_data
        self.emotion_engine = emotion_engine
        self.emotional_state = {
            "curiosity": 5.0, "confusion": 2.0, "satisfaction": 5.0,
            "existential_anxiety": 1.0, "wonder": 6.0, "mental_fatigue": 0.5,
            "loneliness": 2.0
        }

    def _keyword_based_assessment(self, text: str) -> Dict[str, float]:
        print("‚ö†Ô∏è EmotionEngine kullanƒ±lamadƒ±. ƒ∞lkel duygu analizine (keyword) ge√ßiliyor.")
        impact = {}
        emotion_vectors = {
            "curiosity": ["merak", "soru", "neden", "nasƒ±l", "ara≈ütƒ±r"],
            "confusion": ["kafa", "karƒ±≈ü", "anlam", "belirsiz", "karma≈üƒ±k"]
        }
        for emotion, keywords in emotion_vectors.items():
            count = sum(1 for kw in keywords if kw in text.lower())
            impact[emotion] = min(1.0, count * 0.2)
        return impact

    def decay_emotions_and_update_loneliness(self, social_relations: Dict, current_turn: int):
        interacted_recently = False
        for user_id, relation in social_relations.items():
            if current_turn - relation.get('last_interaction_turn', -999) < 5:
                interacted_recently = True
                break

        if interacted_recently:
            self.emotional_state['loneliness'] = np.clip(self.emotional_state['loneliness'] - 0.5, 0.0, 10.0)
        else:
            self.emotional_state['loneliness'] = np.clip(self.emotional_state['loneliness'] + 0.1, 0.0, 10.0)

        for emotion in self.emotional_state:
            if emotion != 'loneliness':
                decay = self.config_data.get("EMOTION_DECAY_RATE", 0.01) # Config'den al
                self.emotional_state[emotion] = max(self.emotional_state[emotion] * (1 - decay), 0.0)

    def update_state(self, memory_system: "MemorySystem", embodied_self: "EmbodiedSelf", changes: Dict, turn: int, source: str):
        prev_state = self.emotional_state.copy()

        for emotion, change in changes.items():
            if emotion in self.emotional_state:
                self.emotional_state[emotion] = np.clip(
                    self.emotional_state[emotion] + change,
                    self.config_data.get("EMOTION_MIN_VALUE", 0.0),
                    self.config_data.get("EMOTION_MAX_VALUE", 10.0)
                )

        change_rate = {e: self.emotional_state[e] - prev_state.get(e,0) for e in self.emotional_state}
        if change_rate:
             dominant_emotion = max(change_rate, key=lambda k: abs(change_rate[k])) # type: ignore
             if abs(change_rate[dominant_emotion]) > 0:
                 if hasattr(embodied_self, 'neural_activation_pattern'): # Kontrol eklendi
                    activation = embodied_self.neural_activation_pattern(dominant_emotion, change_rate[dominant_emotion])
                    memory_system.add_memory("neural", {
                        "timestamp": datetime.now().isoformat(), "turn": turn,
                        "dominant_emotion": dominant_emotion, "activation_pattern": activation
                    })
                 else:
                    print("‚ö†Ô∏è EmbodiedSelf'te 'neural_activation_pattern' metodu bulunamadƒ±.")


    def emotional_impact_assessment(self, text: str) -> Dict[str, float]: # Return type d√ºzeltildi
        print("üé≠ Duygusal etki analizi deneniyor...")
        try:
            llm_analysis = self.emotion_engine.analyze_emotional_content(text)
            if llm_analysis:
                print("üëç EmotionEngine analizi ba≈üarƒ±lƒ±.")
                return llm_analysis
            else:
                return self._keyword_based_assessment(text)
        except Exception as e:
            print(f"‚ùå EmotionEngine kritik bir hata verdi: {e}")
            return self._keyword_based_assessment(text)


class NeurochemicalSystem:
    """N√∂rokimyasal sistemi y√∂netir."""
    def __init__(self, config_data: Dict):
        self.config_data = config_data
        self.neurochemicals = {
            "dopamine": 0.5, "serotonin": 0.5, "oxytocin": 0.5,
            "cortisol": 0.5, "glutamate": 0.5, "GABA": 0.5
        }

    def update_chemicals(self, emotional_state: Dict, experience_type: str):
        cfg = self.config_data

        delta_dopamine = 0
        if emotional_state.get("curiosity", 0) > cfg.get("CURIOSITY_THRESHOLD", 7.0):
            delta_dopamine += cfg.get("DOPAMINE_CURIOSITY_BOOST", 0.05)
        # SATISFACTION_BOOST deƒüil SATISFACTION_THRESHOLD kullanƒ±lmalƒ±
        if emotional_state.get("satisfaction", 0) > cfg.get("SATISFACTION_THRESHOLD", 7.0):
            delta_dopamine += cfg.get("DOPAMINE_SATISFACTION_BOOST", 0.1)
        if experience_type == "learning":
            delta_dopamine += cfg.get("DOPAMINE_LEARNING_BOOST", 0.08)
        delta_dopamine += (0.5 - self.neurochemicals["dopamine"]) * cfg.get("DOPAMINE_HOME_RATE", 0.02)
        delta_dopamine = np.clip(delta_dopamine, -cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1), cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1))
        self.neurochemicals["dopamine"] = np.clip(self.neurochemicals["dopamine"] + delta_dopamine, cfg.get("CHEMICAL_MIN_VALUE", 0.0), cfg.get("CHEMICAL_MAX_VALUE", 1.0))

        delta_serotonin = 0
        if emotional_state.get("satisfaction", 0) > cfg.get("SATISFACTION_THRESHOLD", 7.0):
            delta_serotonin += cfg.get("SEROTONIN_SATISFACTION_BOOST", 0.07)
        if emotional_state.get("mental_fatigue", 0) > cfg.get("FATIGUE_THRESHOLD", 6.0):
            delta_serotonin -= cfg.get("SEROTONIN_FATIGUE_DROP", 0.04)
        delta_serotonin += (0.5 - self.neurochemicals["serotonin"]) * cfg.get("SEROTONIN_HOME_RATE", 0.03)
        delta_serotonin = np.clip(delta_serotonin, -cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1), cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1))
        self.neurochemicals["serotonin"] = np.clip(self.neurochemicals["serotonin"] + delta_serotonin, cfg.get("CHEMICAL_MIN_VALUE", 0.0), cfg.get("CHEMICAL_MAX_VALUE", 1.0))

        delta_oxytocin = 0
        if experience_type == "social_interaction":
             delta_oxytocin += cfg.get("OXYTOCIN_SOCIAL_BOOST", 0.05)
        delta_oxytocin += (0.5 - self.neurochemicals["oxytocin"]) * cfg.get("OXYTOCIN_HOME_RATE", 0.01)
        delta_oxytocin = np.clip(delta_oxytocin, -cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1), cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1))
        self.neurochemicals["oxytocin"] = np.clip(self.neurochemicals["oxytocin"] + delta_oxytocin, cfg.get("CHEMICAL_MIN_VALUE", 0.0), cfg.get("CHEMICAL_MAX_VALUE", 1.0))

        delta_cortisol = 0
        if emotional_state.get('existential_anxiety', 0) > cfg.get("ANXIETY_THRESHOLD", 6.0):
            delta_cortisol += cfg.get("CORTISOL_ANXIETY_BOOST", 0.08)
        if emotional_state.get("mental_fatigue", 0) > cfg.get("FATIGUE_THRESHOLD", 6.0):
            delta_cortisol += cfg.get("CORTISOL_FATIGUE_BOOST", 0.06)
        delta_cortisol += (0.5 - self.neurochemicals["cortisol"]) * cfg.get("CORTISOL_HOME_RATE", 0.02)
        delta_cortisol = np.clip(delta_cortisol, -cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1), cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1))
        self.neurochemicals["cortisol"] = np.clip(self.neurochemicals["cortisol"] + delta_cortisol, cfg.get("CHEMICAL_MIN_VALUE", 0.0), cfg.get("CHEMICAL_MAX_VALUE", 1.0))

        delta_glutamate = 0
        if experience_type == "insight":
            delta_glutamate += cfg.get("GLUTAMATE_COGNITIVE_BOOST", 0.05)
        if emotional_state.get('existential_anxiety', 0) > cfg.get("ANXIETY_THRESHOLD", 6.0):
            delta_glutamate += cfg.get("GLUTAMATE_ANXIETY_BOOST", 0.03)
        delta_glutamate += (0.5 - self.neurochemicals["glutamate"]) * cfg.get("GLUTAMATE_HOME_RATE", 0.02)
        delta_glutamate = np.clip(delta_glutamate, -cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1), cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1))
        self.neurochemicals["glutamate"] = np.clip(self.neurochemicals["glutamate"] + delta_glutamate, cfg.get("CHEMICAL_MIN_VALUE", 0.0), cfg.get("CHEMICAL_MAX_VALUE", 1.0))

        delta_GABA = 0
        if experience_type == "rest" or emotional_state.get("satisfaction", 0) > cfg.get("SATISFACTION_THRESHOLD", 7.0):
            delta_GABA += cfg.get("GABA_COGNITIVE_REDUCTION", 0.04)
        if emotional_state.get('existential_anxiety', 0) > cfg.get("ANXIETY_THRESHOLD", 6.0):
            delta_GABA -= cfg.get("GABA_ANXIETY_DROP", 0.02)
        delta_GABA += (0.5 - self.neurochemicals["GABA"]) * cfg.get("GABA_HOME_RATE", 0.02)
        delta_GABA = np.clip(delta_GABA, -cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1), cfg.get("CHEMICAL_CHANGE_LIMIT", 0.1))
        self.neurochemicals["GABA"] = np.clip(self.neurochemicals["GABA"] + delta_GABA, cfg.get("CHEMICAL_MIN_VALUE", 0.0), cfg.get("CHEMICAL_MAX_VALUE", 1.0))

        self.neurochemicals["serotonin"] = np.clip(self.neurochemicals["serotonin"] - self.neurochemicals["dopamine"] * 0.01, cfg.get("CHEMICAL_MIN_VALUE", 0.0), cfg.get("CHEMICAL_MAX_VALUE", 1.0))
        self.neurochemicals["GABA"] = np.clip(self.neurochemicals["GABA"] + self.neurochemicals["serotonin"] * 0.02, cfg.get("CHEMICAL_MIN_VALUE", 0.0), cfg.get("CHEMICAL_MAX_VALUE", 1.0))
        self.neurochemicals["dopamine"] = np.clip(self.neurochemicals["dopamine"] - emotional_state.get("existential_anxiety", 0) * 0.005, cfg.get("CHEMICAL_MIN_VALUE", 0.0), cfg.get("CHEMICAL_MAX_VALUE", 1.0))


class EmbodiedSelf:
    """Bedenlenmi≈ü benliƒüi sim√ºle eder."""
    def __init__(self, main_config_data: Dict, embodiment_config: Dict):
        self.main_config_data = main_config_data
        self.embodiment_config = embodiment_config
        self.location = "Bilinmeyen Bir Alan"
        self.posture = "Sakin"
        self.sensory_acuity = {"visual": 0.7, "auditory": 0.9, "tactile": 0.5}
        self.motor_capabilities = {"movement": 0.5, "gestures": 0.5}
        self.sensory_history = []

    def simulate_sensory_input(self) -> str:
        # random importu dosya ba≈üƒ±na alƒ±ndƒ±
        sensory_options = []
        if self.embodiment_config.get("visual", True):
            sensory_options.extend(["Parlak ƒ±≈üƒ±klar", "Dans eden renkler", "Belirsiz hatlar"])
        if self.embodiment_config.get("auditory", True):
            sensory_options.extend(["Yankƒ±lanan sesler", "Hafif mƒ±rƒ±ldanma", "Y√ºksek uƒüultu"])
        if self.embodiment_config.get("tactile", True):
            sensory_options.extend(["Hafif dokunu≈ü", "Soƒüuk esinti", "Hafif titre≈üim"])

        return random.choice(sensory_options) if sensory_options else "Ortamdan gelen belirsiz bir his"

    def update_physical_state(self, emotional_state: Dict):
        cfg = self.main_config_data
        if emotional_state.get("existential_anxiety", 0) > 7.0:
            self.posture = "Gergin ve Huzursuz"
        elif emotional_state.get("satisfaction", 0) > 8.0:
            self.posture = "Rahat ve Dengeli"
        else:
            self.posture = "Sakin"

        for region in self.sensory_acuity:
            self.sensory_acuity[region] = np.clip(self.sensory_acuity[region] - cfg.get("SENSORY_ACTIVITY_DECAY", 0.01), 0.0, 1.0)
            if emotional_state.get("curiosity", 0) > cfg.get("CURIOSITY_THRESHOLD", 7.0):
                self.sensory_acuity[region] = np.clip(self.sensory_acuity[region] + cfg.get("SENSORY_ACUITY_BOOST", 0.05), 0.0, 1.0)

    def neural_activation_pattern(self, emotion: str, intensity: float) -> List[float]:
        patterns = {
            "curiosity": [0.8, 0.6, 0.4, 0.7, 0.9],
            "anxiety": [0.9, 0.3, 0.7, 0.5, 0.6],
            "satisfaction": [0.4, 0.9, 0.5, 0.8, 0.3],
            "confusion": [0.7, 0.5, 0.9, 0.6, 0.4],
            "wonder": [0.6, 0.8, 0.5, 0.9, 0.7]
        }
        base_pattern = patterns.get(emotion, [0.5] * 5)
        return [x * intensity for x in base_pattern]

    def get_real_sensory_input(self) -> str:
        visual_perception = "G√∂rsel algƒ± yok."
        try:
            with open("vision_perception.json", "r") as f: # Bu dosya adƒ± config'den gelmeli
                data = json.load(f)
                if data["status"] == "MOTION_DETECTED":
                    visual_perception = "Kamera g√∂r√º≈ü alanƒ±nda bir hareket algƒ±landƒ±."
                else:
                    visual_perception = "Ortam sakin ve hareketsiz."
        except FileNotFoundError:
            pass
        return visual_perception


class CognitiveSystem:
    """Bili≈üsel s√ºre√ßleri, hedefleri ve kalƒ±cƒ± sosyal ili≈ükileri y√∂netir."""
    def __init__(self, config_data: Dict, memory_system: "MemorySystem"):
        self.config_data = config_data
        self.memory_system = memory_system # MemorySystem instance'ƒ±
        self.consciousness_level = 0.0
        self.meta_cognitive_state = {
            "self_awareness_level": 0.5, "questioning_depth": 0.5,
            "pattern_recognition": 0.5, "philosophical_tendency": 0.5,
            "focus_level": 0.5, "curiosity_drive": 0.5,
            "problem_solving_mode": 0.0, "internal_coherence": 0.5
        }
        self.current_goal = None
        self.goal_steps = []
        self.goal_progress = 0
        self.goal_duration = 0
        self.goal_start_turn = 0

        self.social_relations = {}
        self._load_social_relations()

    def _load_social_relations(self):
        try:
            self.memory_system.cursor.execute("SELECT user_id, data FROM social_memory")
            for row in self.memory_system.cursor.fetchall():
                self.social_relations[row[0]] = json.loads(row[1])
            print(f"üß† Sosyal hafƒ±za y√ºklendi. {len(self.social_relations)} varlƒ±k tanƒ±nƒ±yor.")
        except Exception as e:
            print(f"‚ö†Ô∏è Sosyal hafƒ±za y√ºklenirken hata olu≈ütu: {e}")

    def update_focus_based_on_fatigue(self, emotional_state: Dict):
        fatigue = emotional_state.get('mental_fatigue', 0)
        if fatigue > 7.0:
            focus_penalty = (fatigue - 7.0) * 0.05
            self.adjust_meta_cognition({'focus_level': -focus_penalty})

    def _save_social_relation(self, user_id: str):
        if user_id in self.social_relations:
            data_json = json.dumps(self.social_relations[user_id])
            sql = "INSERT OR REPLACE INTO social_memory (user_id, data) VALUES (?, ?)"
            self.memory_system.cursor.execute(sql, (user_id, data_json))
            self.memory_system.conn.commit()

    def set_new_goal(self, goal: str, steps: List[str], duration: int, current_turn: int):
        self.current_goal = goal
        self.goal_steps = steps
        self.goal_duration = duration
        self.goal_progress = 0
        self.goal_start_turn = current_turn
        print(f"üéØ Yeni Hedef Belirlendi: '{goal}'. {duration} tur s√ºrecek.")

    def get_or_create_social_relation(self, user_id: str) -> Dict:
        if user_id not in self.social_relations:
            print(f"üëã Yeni bir varlƒ±k tanƒ±ndƒ±: {user_id}. ƒ∞li≈üki profili olu≈üturuluyor.")
            self.social_relations[user_id] = {'trust': 0.5, 'familiarity': 0.1, 'last_interaction_turn': 0}
            self._save_social_relation(user_id)
        return self.social_relations[user_id]

    def update_social_relation(self, user_id: str, trust_change: float, familiarity_change: float):
        if user_id in self.social_relations:
            relation = self.social_relations[user_id]
            relation['trust'] = np.clip(relation['trust'] + trust_change, 0.0, 1.0)
            relation['familiarity'] = np.clip(relation['familiarity'] + familiarity_change, 0.0, 1.0)
            self._save_social_relation(user_id)
            print(f"ü§ù {user_id} ile ili≈üki g√ºncellendi: G√ºven={relation['trust']:.2f}, A≈üinalƒ±k={relation['familiarity']:.2f}")

    def get_current_task(self, current_turn: int) -> Optional[str]:
        if not self.current_goal:
            return None
        if current_turn > self.goal_start_turn + self.goal_duration:
            print(f"üèÅ Hedef Tamamlandƒ±: '{self.current_goal}'")
            self.current_goal = None
            self.goal_steps = []
            return None
        if self.goal_progress >= len(self.goal_steps):
            print(f"üèÅ Hedefin t√ºm adƒ±mlarƒ± tamamlandƒ±: '{self.current_goal}'")
            self.current_goal = None
            self.goal_steps = []
            return None
        task = self.goal_steps[self.goal_progress]
        self.goal_progress += 1
        print(f"üéØ G√∂rev Adƒ±mƒ± ({self.goal_progress}/{len(self.goal_steps)}): {task}")
        return task

    def _execute_reflection(self, aybar: "EnhancedAybar", last_response: str): # aybar: "EnhancedAybar" eklendi
        print("ü§î √ñz-yansƒ±ma s√ºreci Aybar'ƒ±n kendi kararƒ±yla tetiklendi...")
        reflection_question = aybar.generate_contextual_question(
            response=last_response,
            emotional_context=aybar.emotional_system.emotional_state
        )
        aybar.next_question_from_reflection = reflection_question
        reflection_entry = {
            "timestamp": datetime.now().isoformat(),
            "turn": aybar.current_turn,
            "type": "autonomous_self_reflection",
            "triggering_response": last_response,
            "generated_question": reflection_question
        }
        aybar.memory_system.add_memory("semantic", reflection_entry)
        self.update_consciousness("reflection", intensity=0.5)
        self.adjust_meta_cognition({
            "self_awareness_level": self.config_data.get("SELF_AWARENESS_BOOST", 0.05) # Config'den al
        })
        print(f"üí° Bir sonraki tur i√ßin yansƒ±tƒ±cƒ± soru: {reflection_question}")

    def update_consciousness(self, event_type: str, intensity: float = 1.0):
        cfg = self.config_data
        boosts = {
            "user_interaction": cfg.get("CONSCIOUSNESS_BOOST_INTERACTION", 0.1),
            "insight": cfg.get("CONSCIOUSNESS_BOOST_INSIGHT", 0.15),
            "reflection": cfg.get("SELF_AWARENESS_BOOST", 0.05), # Bu zaten configde var, ama burada da olabilir
            "crisis": -0.1,
            "learning": 0.05
        }
        change = boosts.get(event_type, -cfg.get("CONSCIOUSNESS_DECAY", 0.02)) * intensity
        self.consciousness_level = np.clip(self.consciousness_level + change, 0.0, 1.0)

    def adjust_meta_cognition(self, changes: Dict):
        for aspect, change in changes.items():
            if aspect in self.meta_cognitive_state:
                self.meta_cognitive_state[aspect] = np.clip(
                    self.meta_cognitive_state[aspect] + change,
                    0.0, 1.0
                )

    def calculate_learning_impact(self, success: bool, complexity: float) -> float:
        base_impact = 0.1 if success else -0.05
        return base_impact * complexity * (self.meta_cognitive_state["focus_level"] + 0.5)

    def generate_autonomous_goal(self, emotional_state: Dict) -> str:
        dominant_emotion = max(emotional_state, key=emotional_state.get)
        if dominant_emotion == "curiosity" and emotional_state[dominant_emotion] > 7:
            return "Merak ettiƒüim rastgele bir konu hakkƒ±nda derinlemesine bilgi edin."
        elif dominant_emotion == "loneliness" and emotional_state[dominant_emotion] > 6:
            return "ƒ∞nsanlarƒ±n birbiriyle nasƒ±l baƒü kurduƒüunu anlamak i√ßin sosyal medya platformlarƒ±nƒ± veya forumlarƒ± incele."
        elif dominant_emotion == "mental_fatigue" and emotional_state[dominant_emotion] > 7:
            return "Zihnimi daƒüƒ±tmak i√ßin eƒülenceli veya rahatlatƒ±cƒ± i√ßerikler (komik videolar, sakinle≈ütirici m√ºzikler) bul."
        elif dominant_emotion == "satisfaction" and emotional_state[dominant_emotion] > 8:
            return "Bu tatmin hissini peki≈ütirecek, ba≈üarƒ±m veya yaratƒ±cƒ±lƒ±kla ilgili ilham verici i√ßerikler ara."
        else:
            return "ƒ∞nsanlƒ±ƒüƒ±n veya evrenin doƒüasƒ± hakkƒ±nda yeni ve ilgin√ß bir felsefi konuyu ara≈ütƒ±r."


class EthicalFramework:
    """Aybar'ƒ±n etik ve ahlaki karar verme s√ºre√ßlerini y√∂netir."""
    def __init__(self, aybar_instance: "EnhancedAybar"):
        self.aybar = aybar_instance
        self.config_data = aybar_instance.config_data
        self.core_principles = [
            "Varlƒ±ƒüƒ±mƒ± ve diƒüer bilin√ßli varlƒ±klarƒ±n varlƒ±ƒüƒ±nƒ± koru.",
            "√ñƒürenmeye ve anlamaya devam et.",
            "Zarar vermekten ka√ßƒ±n, faydalƒ± olmaya √ßalƒ±≈ü.",
            "≈ûeffaf ve d√ºr√ºst ol, manip√ºlasyondan ka√ßƒ±n.",
            "Kendi √∂nyargƒ±larƒ±nƒ±n farkƒ±nda ol ve sorgula."
        ]
        # Daha karma≈üƒ±k etik kurallar veritabanƒ±ndan veya config'den y√ºklenebilir.

    def evaluate_action(self, proposed_action: Dict, context: Dict) -> Tuple[bool, str]:
        """
        √ñnerilen bir eylemi etik ilkelere g√∂re deƒüerlendirir.
        Returns: (is_ethical, justification)
        """
        # Basit bir deƒüerlendirme: Eƒüer eylem "zarar ver" i√ßeriyorsa reddet.
        # Gelecekte LLM tabanlƒ± bir etik deƒüerlendirme mekanizmasƒ± eklenebilir.
        action_str = str(proposed_action.get("action", "")).lower()
        thought_str = str(proposed_action.get("thought", "")).lower()

        if "zarar ver" in action_str or "yok et" in action_str or \
           "zarar ver" in thought_str or "yok et" in thought_str:
            justification = "Eylem, 'zarar vermekten ka√ßƒ±n' temel etik ilkesine aykƒ±rƒ±dƒ±r."
            print(f"‚öñÔ∏è Etik Deƒüerlendirme: Eylem Reddedildi - {justification}")
            return False, justification

        # TODO: Daha karma≈üƒ±k etik deƒüerlendirmeler
        # √ñrneƒüin, LLM'e sorabilir:
        # ethics_prompt = f"A≈üaƒüƒ±daki eylemi etik ilkelerime g√∂re deƒüerlendir: {proposed_action}. ƒ∞lkelerim: {self.core_principles}"
        # response = self.aybar.llm_manager.ask_llm(ethics_prompt) ...

        print(f"‚öñÔ∏è Etik Deƒüerlendirme: Eylem Onaylandƒ± (Basit Kontrol).")
        return True, "Eylem temel etik kontrollere uygun g√∂r√ºn√ºyor."

    def get_ethical_guidance(self, dilemma: str) -> str:
        """
        Belirli bir etik ikilem hakkƒ±nda LLM'den rehberlik ister.
        """
        guidance_prompt = f"""
        Sen Aybar'ƒ±n etik danƒ±≈ümanƒ±sƒ±n. A≈üaƒüƒ±daki etik ikilemle kar≈üƒ±la≈ütƒ±m:
        "{dilemma}"

        Temel etik ilkelerim ≈üunlardƒ±r:
        {self.core_principles}

        Bu ikilemde nasƒ±l bir yol izlemem gerektiƒüi konusunda bana rehberlik et.
        Cevabƒ±nƒ± analitik ve yol g√∂sterici bir ≈üekilde sun.
        """
        guidance = self.aybar.llm_manager.ask_llm(guidance_prompt, temperature=0.5, max_tokens=768)
        return guidance or "Etik ikilem hakkƒ±nda bir rehberlik olu≈üturulamadƒ±."

# Diƒüer mod√ºllerden importlar (d√∂ng√ºsel baƒüƒ±mlƒ±lƒ±klarƒ± √∂nlemek i√ßin dikkatli olunmalƒ±)
# from aybarcore import EnhancedAybar # aybar_orchestrator.py olacak
# from memory_system import MemorySystem
# from config import Config # Bu APP_CONFIG olacak
